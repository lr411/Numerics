%Chapter Results


\section{Results}

\subsection{General results}

\subsubsection{Order of accuracy}
As described in the previous parts of this document, the theoretical order of accuracy of the numerical schemes used is:
\begin{itemize}
	\item FTBS: 1
	\item CTCS: 2
	\item Lax Wendroff: 2
	\item CNCS: 2
\end{itemize}
The following figure \ref{fig:orderofacc} shows the results of the experiment of 10 runs of the 4 schemes, with nt and nx varying between 50 and 500, with a step of 50.
\begin{figure}[H]
	\begin{center}
		\includegraphics[width=4in]{graphics/Accuracy.png}
	\end{center}%
	\caption[Order of accuracy of numerical methods]{ \em Estimated order of accuracy of numerical methods versus the size of $\Delta x$, with nt and nx varying between 50 and 500, with a step of 50}
	\label{fig:orderofacc}
\end{figure}

\subsubsection{Computational cost}
We have estimated the computational cost timing code execution of the numerical methods and the following is a figure showing the estimated dependency of the order of magnitude of the time taken to execute the code vs nx, details of the experiment will be given in \ref{sec:compcost}. The LaxWendroff method proves to be particularly expensive, whereas the CNCS, although it involves handling matrices, has been the fastest algorithm, most probably thanks to the efficiency of the sparse matrices Python library.
\begin{figure}[H]
	\begin{center}
		\includegraphics[width=4in]{graphics/Timing.png}
	\end{center}%
	\caption[computational cost of numerical methods]{ \em Estimated execution time vs nx, for the numerical methods. Log-log plot has been used for estimation of the order of magnitude of the dependency.}
	\label{fig:timing}
\end{figure}

\subsection{Order of accuracy}
To test the order of accuracy, 10 runs have been made of the 4 schemes, keeping the Courant number constant throughout, and varying nx, keeping nt=nx to avoid rounding errors. The function $sin(4\pi x)$ has been used as initial condition, it's smooth and with a single frequency and therefore does not suffer from dispersion errors that could affect the error.
The results of the runs are shown in figure \ref{fig:orderofacc} , and the estimated order of accuracy for the methods is as follows:
\begin{itemize}
\item FTBS: 0.91
\item CTCS: 1.80
\item CNCS: 1.79
\item LaxWendroff: 1.79
\end{itemize}
The results are close to the theoretical ones.

\subsubsection{Computational cost}
\label{sec:compcost}
We have estimated the computational cost of the various numerical methods, timing code execution with the "timeit.default_timer()" Python routine, that returns the fraction of seconds a code has taken to run, measured between two calls to default_timer().
of the numerical methods and the following is a figure showing the estimated dependency of the order of magnitude of the time taken to execute the code vs nx, details of the experiment will be given in \ref{sec:compcost}. The LaxWendroff method proves to be particularly expensive, whereas the CNCS, although it involves handling matrices, has been the fastest algorithm, most probably thanks to the efficiency of the sparse matrices Python library.

